var request = require('request-promise');
var _ = require('lodash');
var Promise = require('bluebird');

var config = require('./configurator.config');
//var pems = require('intel-cacerts').list;
//var pems = require('intcCerts').getExternalCAs();

// var getPems = Promise.promisify(require('intel-cacerts-live').list);
var getPems = function() {
  return Promise.resolve(require('intel-cacerts').ca);
}


module.exports = function (globalOptions) {

  var scopeNeeded = globalOptions.scope;
  var iamUser = globalOptions.user;
  var iamPass = globalOptions.pass;
  var maxRetries = globalOptions.maxRetries || 3;
  var retryDelay = globalOptions.retryDelay ? globalOptions.retryDelay * 1000 : 3000;
  var validatePath = globalOptions.validatePath || '/Windows/Auth';

  var iamServiceRoot = globalOptions.serviceRoot || config.iamServiceRoot;
  if (!scopeNeeded || !iamUser || !iamPass) {
    throw new Error('user, pass, and scope are required for configuration.');
  }

  var cachedBearerToken;

  return {
    validateWindowsAuthToken: wrap(validateWindowsAuthToken),
    validateGroupMembership: wrap(validateGroupMembership)
  };

  /*
   *  Validate group membership with IAM. There is a hard limit of 20 groups on each request from IAM.
   *  Groups collection: [
   *    {
   *      "name": "CN=GitHub_IT,OU=Rialto,OU=Application Managed,OU=Groups,DC=amr,DC=corp,DC=intel,DC=com",
   *      "type": "CORPAD"
   *    }
   *    ...
   *  ]
   */
  function validateGroupMembership(bearerToken, idsid, groups) {
    if (groups.length > 20) {
      throw new Error('Too many groups to validate. Please limit group validation requests to no more than 20.');
    }
    return getPems('both').then(function (pems) {
      var opts = {
        method: 'POST',
        url: iamServiceRoot + '/Authorizations',
        ca: pems,
        headers: {
          'Authorization': 'Bearer ' + bearerToken.access_token,
          'Content-Type': 'application/json'
        },
        body: {
          'userName': idsid,
          'memberships': groups
        },
        json: true
      };
      return request(opts);
    });
  }

  function validateWindowsAuthToken(bearerToken, windowsAuthToken, appId) {
    var data = {Token: windowsAuthToken};
    if (appId) {
      data.AppId = appId;
    }
    return getPems('both').then(function (pems) {
        return request.post({
          url: iamServiceRoot + validatePath,
          form: data,
          ca: pems,
          auth: {bearer: bearerToken.access_token}
        })
      })
      .then(JSON.parse)
  }


  /* private */
  function wrap(fn) {
    return function wrapped() {
      var retried = 0;
      var args = [];
      _.each(arguments, function (arg) {
        args.push(arg);
      });
      return (function inner() {
        if (retried > maxRetries) {
          throw new Error('Exceeded retries.');
        }
        return ensureFreshBearerToken()
          .then(function (bearerToken) {
            return fn.apply(this, [bearerToken].concat(args))
          })
          .catch(function (error) {
            console.error('Caught error while calling. ');
            console.error(error);
            retried++;
            cachedBearerToken = null;
            return Promise.delay(retryDelay)
              .then(inner);
          });
      })();
    }
  }

  function ensureFreshBearerToken() {
    if (cachedBearerToken && cachedBearerToken.expiresAt > Date.now()) {
      return Promise.resolve(cachedBearerToken);
    }
    else {
      return getBearerToken()
        .then(function (newToken) {
          newToken.expiresAt = Date.now() + (newToken.expires_in * 1000);
          return cachedBearerToken = newToken;
        })
    }
  }

  function getBearerToken() {
    var scopeRequest = _.extend({grant_type: 'client_credentials'}, {scope: scopeNeeded});
    return getPems('both').then(function (pems) {
        return request.post({
          url: iamServiceRoot + '/token',
          form: scopeRequest,
          ca: pems,
          auth: {user: iamUser, pass: iamPass}
        })
      })
      .then(JSON.parse)
  }
};

