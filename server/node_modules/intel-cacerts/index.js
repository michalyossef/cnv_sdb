module.exports = config
module.exports.config = config
module.exports.ensureFreshCerts = updateCaCache
module.exports.waitIfUpdating = waitIfUpdating
module.exports.generateExtraCaCertsFile = generateExtraCaCertsFile

// external modules
var fs = require('fs')
var path = require('path')
var request = require('request')
var unzip = require('unzip')
var concat = require('concat-stream')
var fileExists = require('file-exists')
var Promise = require('bluebird')

var shippedCerts = require('./caShipped')
var override

var caCachePath = path.resolve(__dirname, './caCache.js')
var caCacheWIPPath = path.resolve(__dirname, './caCacheWIP.js')
var caOverridePath = './caOverride'

// either a promise that will resolve when complete or false if not updating.
// waitIfUpdating always returns a promise
var updatingCas = false

// cache expires after this many milliseconds
var timeToLive = 1000 * 60 * 60 * 24 * 7 // 7 days

var certUrls = [
	'https://certificates.intel.com/repository/certificates/PublicSHA2RootChain-Base64.zip',
	'https://certificates.intel.com/repository/certificates/IntelSHA2RootChain-Base64.zip'
]
var validFilesRegex = /\.(cer|crt)/i
var cas
var updateCas

// config can be called off the main require, or directly using the config method. They do the same thing.
function config (options) {
	return waitIfUpdating()
		.then(function () {
			options = options || {}
			if (options.override) {
				if (typeof options.override === 'string') {
					override = require(options.override)
					delete require.cache[require.resolve(options.override)]
				} else {
					override = require(caOverridePath)
					delete require.cache[require.resolve(caOverridePath)]
				}
			} else {
				if (typeof options.override === 'boolean') {
					override = false
				}
			}
			if (override) {
				return
			}
			if (options.certUrl) {
				if (typeof options.certUrl === 'string') {
					certUrls = [options.certUrl]
				} else {
					if (Array.isArray(options.certUrl)) {
						certUrls = options.certUrl
					} else {
						throw new Error('certUrl must be a string or array of strings.')
					}
				}
				deleteCaCache()
			}
			if (options.timeToLive > -1) {
				timeToLive = options.timeToLive
			}
			if (options.filePattern) {
				validFilesRegex = options.filePattern
			}
			return updateCaCache()
		})
}

var caDefinition = {
	get: function () {
		if (override) {
			return override
		}
		cas = cas || readCacheFile() || shippedCerts || undefined
		if (!cas) { throw new Error('Shipped certs are missing.') }

		updateCaCache()
			.catch(function (error) {
				console.log('problem updating cache in get.', error)
			})
		return cas
	},
	'set': function () {
		throw new Error('Certs may not be overridden directly.')
	},
	enumerable: true,
	configurable: true
}

// main way of getting certificates back
Object.defineProperty(module.exports, 'ca', caDefinition)
// list included for backwards compatibility
Object.defineProperty(module.exports, 'list', caDefinition)

function updateCaCache () {
	if (override) {
		debug('Override in place')
		return Promise.resolve(override)
	}
	if (updatingCas) {
		debug('Already updating CAs')
		// return Promise.resolve()
		return updatingCas
	}
	updateCas = true
	if (fileExists(caCachePath)) {
		var cacheTime = fs.statSync(caCachePath).mtime
		var now = new Date()
		var howOld = now - cacheTime
		if (howOld < timeToLive) {
			updateCas = false
		}
	}

	if (updateCas) {
		var foundCerts = 0
		var startCacheFile = require('stream').Readable()
		startCacheFile.push('module.exports = [')
		startCacheFile.push('\r\n')
		startCacheFile.push(null)
		startCacheFile.pipe(fs.createWriteStream(caCacheWIPPath, {encoding: 'utf8'}))

		updatingCas = Promise.map(certUrls, function (certUrl) {
			return new Promise(function (resolve, reject) {
				var certRequest = request({
					method: 'GET',
					uri: certUrl,
					proxy: false,
					ca: module.exports.ca
				})
					.on('error', function () {
						// retry using shipped certs if we can't get to certificates.intel.com
						certRequest = request({
							method: 'GET',
							uri: certUrl,
							proxy: false,
							ca: shippedCerts
						})
							.on('response', handleResponse)
							.on('error', function (error) {
								reject(error)
							})
					})
					.on('response', handleResponse)

				function handleResponse () {
					certRequest
						.pipe(unzip.Parse({verbose: false}))
						.on('entry', function (entry) {
							debug('unzipped: ', entry.path)
							var certName = entry.path
							if (validFilesRegex.test(certName)) {
								foundCerts++
								entry.pipe(concat(function (fileContents) {
									var contents = require('stream').Readable()
									contents.push(JSON.stringify(fileContents.toString()) + ',')
									contents.push('\r\n')
									contents.push(null)
									contents.pipe(fs.createWriteStream(caCacheWIPPath, {encoding: 'utf8', flags: 'a'}))
								}))
							} else {
								debug('skipping file', certName)
								entry.autodrain()
							}
						})
						.on('close', function () {
							resolve()
						})
						.on('error', function (error) {
							if (error.message.match('invalid signature')) {
								reject(new Error('Not a valid zip file.'))
							} else {
								reject(error)
							}
						})
				}
			})
		}, {concurrency: 1})
			.then(function () {
				if (!foundCerts) {
					throw new Error('No Certs found inside: ' + JSON.stringify(certUrls))
				}
				return new Promise(function (resolve, reject) {
					var endCacheFile = require('stream').Readable()
					endCacheFile.push('];')
					endCacheFile.push('\r\n')
					endCacheFile.push(null)
					endCacheFile.pipe(fs.createWriteStream(caCacheWIPPath, {encoding: 'utf8', flags: 'a'}))
						.on('close', function () {
							// test to ensure cache wip file successfully wrote.
							try {
								require(caCacheWIPPath);
								fs.renameSync(caCacheWIPPath, caCachePath);
								cas = readCacheFile()
								resolve(cas)
							}
							catch (error) {
								console.log('failed trying to write cache to disk.')
							}
						})
						.on('error', function (error) {
							reject(error)
						})
				})
			})
			.finally(function () {
				debug('done updating CAs')
				updatingCas = false
			})
		return updatingCas
	} else {
		return Promise.resolve(readCacheFile())
	}
}

function generateExtraCaCertsFile (extraCaCertsPath) {
	var extraCaCertsWIPPath = extraCaCertsPath + 'wip';
	var foundCerts = 0;
	var extraWIP = fs.createWriteStream(extraCaCertsWIPPath, {encoding: 'utf8'})
	extraWIP.close();
	return Promise.map(certUrls, function (certUrl) {
		return new Promise(function (resolve, reject) {
			var certRequest = request({
				method: 'GET',
				uri: certUrl,
				proxy: false,
				ca: module.exports.ca
			})
				.on('error', function () {
					// retry using shipped certs if we can't get to certificates.intel.com
					certRequest = request({
						method: 'GET',
						uri: certUrl,
						proxy: false,
						ca: shippedCerts
					})
						.on('response', handleResponse)
						.on('error', function (error) {
							reject(error)
						})
				})
				.on('response', handleResponse)

			function handleResponse () {
				certRequest
					.pipe(unzip.Parse({verbose: false}))
					.on('entry', function (entry) {
						debug('unzipped: ', entry.path)
						var certName = entry.path
						if (validFilesRegex.test(certName)) {
							foundCerts++
							entry.pipe(fs.createWriteStream(extraCaCertsWIPPath, {encoding: 'utf8', flags: 'a'}))
						} else {
							debug('skipping file', certName)
							entry.autodrain()
						}
					})
					.on('close', function () {
						resolve()
					})
					.on('error', function (error) {
						if (error.message.match('invalid signature')) {
							reject(new Error('Not a valid zip file.'))
						} else {
							reject(error)
						}
					})
			}
		})
	}, {concurrency: 1})
		.then(function () {
			if (!foundCerts) {
				throw new Error('No Certs found inside: ' + JSON.stringify(certUrls))
			}
			return new Promise(function (resolve, reject) {
				/*
				 var endCacheFile = require('stream').Readable()
				 endCacheFile.push('];')
				 endCacheFile.push('\r\n')
				 endCacheFile.push(null)
				 endCacheFile.pipe(fs.createWriteStream(caCacheWIPPath, {encoding: 'utf8', flags: 'a'}))
				 */
				/*
				 .on('close', function () {
				 */
				// test to ensure cache wip file successfully wrote.
				try {
					// require(caCacheWIPPath);
					fs.renameSync(extraCaCertsWIPPath, extraCaCertsPath);
					// cas = readCacheFile()
					// resolve(cas)
				}
				catch (error) {
					console.log('failed trying to write cache to disk.')
				}
				/*
				 })
				 .on('error', function (error) {
				 reject(error)
				 })
				 */
			})
		})
		.finally(function () {
			debug('done updating CAs')
			updatingCas = false
		})

}

function readCacheFile () {
	var cacheFileContents
	if (fileExists(caCachePath)) {
		try {
			cacheFileContents = require(caCachePath)
			delete require.cache[require.resolve(caCachePath)]
		}
		catch (error) {
			cacheFileContents = undefined;
			deleteCaCache();
		}
	}
	return cacheFileContents
}

function waitIfUpdating () {
	return updatingCas || Promise.resolve()
}

function deleteCaCache () {
	cas = undefined
	if (fileExists(caCachePath)) {
		fs.unlinkSync(caCachePath)
	}
	if (fileExists(caCacheWIPPath)) {
		fs.unlinkSync(require.resolve(caCacheWIPPath))
	}
}

function debug () {
	if (module.exports.debug) {
		var toLog = Array.prototype.slice.call(arguments)
		toLog.unshift('[cacerts]')
		if (typeof module.exports.debug === 'function') {
			module.exports.debug.apply(this, toLog)
		} else {
			console.log.apply(console, toLog)
		}
	}
}
